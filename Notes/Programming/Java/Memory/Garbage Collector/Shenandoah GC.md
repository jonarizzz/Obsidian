**Shenandoah GC** — это один из [[Сборщик Мусора (Garbage Collector, GC)||сборщиков мусора]] в Java, разработанный для низких пауз при сборке мусора независимо от размера [[Heap (Область Памяти)||кучи]]. Он появился в [[{TODO} Java 12||JDK 12]] и предназначен для использования в системах с большими объемами памяти и высокими требованиями к предсказуемой производительности.

### Основные особенности

- **Конкурентная работа** — большинство операций по сборке мусора выполняется параллельно с работой приложения.
- **Низкие паузы** — время пауз не зависит от размера [[Heap (Область Памяти)||кучи]] (обычно в пределах **1–10 мс**).
- **Компактный и дефрагментированный heap** — Shenandoah использует **concurrent compaction**, чтобы избежать [[Фрагментация Памяти (Memory Fragmentation)||фрагментации памяти]].
- **Реализация на основе барьеров** (barrier-based GC) — использует **brooks forwarding barriers** для минимизации времени остановки.

### Как включить Shenandoah GC?

Чтобы использовать Shenandoah GC, необходимо запустить [[Виртуальная Машина Java (Java Virtual Machine, JVM)||JVM]] с соответствующими флагами:

```
java -XX:+UseShenandoahGC -jar your-application.jar
```

Дополнительно можно настроить поведение:

- `-XX:ShenandoahGCHeuristics=compact` — агрессивная дефрагментация.
- `-XX:ShenandoahGCHeuristics=aggressive` — уменьшение количества отложенных [[Объект (Object)||объектов]].
- `-XX:+ShenandoahUncommit` — высвобождение неиспользуемой памяти обратно ОС.


### Когда использовать?

- Важны низкие и предсказуемые паузы.
- Объем [[Heap (Область Памяти)||кучи]] больше 8 ГБ.
- Приложение активно использует [[Многопоточное Программирование (Многопоточка, Multithreading)||многопоточность]] и имеет высокую нагрузку.

### Когда не использовать?

- Если у вас маленький [[Heap (Область Памяти)||heap]] (<4 ГБ), то Shenandoah может быть избыточным.
- Для максимальной пропускной способности (throughput) лучше использовать [[G1 GC||G1 GC]] или [[ZGC||ZGC]].
- Если нужна минимальная нагрузка на CPU, Shenandoah может не подойти, так как он использует больше процессорного времени.

  

