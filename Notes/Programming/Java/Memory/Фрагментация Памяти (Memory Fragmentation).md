Фрагментация памяти в контексте [[Сборщик Мусора (Garbage Collector, GC)||сборщиков мусора (Garbage Collector, GC)]] в Java — это процесс, при котором свободная память [[Heap (Область Памяти)||кучи (heap)]] становится раздробленной на множество небольших несмежных блоков, что может приводить к проблемам с выделением новых [[Объект (Object)||объектов]].

### Виды фрагментации:

- **Внешняя фрагментация**
	- Возникает, когда память содержит достаточное количество свободного пространства, но оно разрознено. В результате крупные объекты не могут быть размещены, даже если в сумме памяти достаточно.
	- В Java это редко становится критической проблемой, так как [[Сборщик Мусора (Garbage Collector, GC)||GC]] периодически выполняет **компактификацию (defragmentation)**, перемещая [[Объект (Object)||объекты]] для объединения свободных блоков.
- **Внутренняя фрагментация**
	- Происходит, когда выделенные блоки памяти больше, чем реально требуется объектам, из-за особенностей выравнивания (alignment) или фиксированных размеров аллокации.
	- В Java внутренняя фрагментация минимизируется за счёт использования размерных классов (TLAB, survivor spaces и т. д.).


### Как GC борется с фрагментацией?

- [[Serial GC||Serial GC]], [[Parallel GC||Parallel GC]]
	- Выполняют “[[Stop-The-World (STW)||stop-the-world]]” паузу и полностью компактифицируют память (перемещают [[Объект (Object)||объекты]] так, чтобы освободить большие непрерывные блоки).
- [[G1 GC||G1 GC (Garbage-First GC)]]
	- Разбивает память на регионы и использует локальную компактификацию в отдельных регионах, минимизируя длительные паузы.
- [[ZGC||ZGC]] и [[Shenandoah GC||Shenandoah GC]]
	- Эти сборщики не делают полной остановки программы и выполняют компактификацию параллельно с выполнением приложения.


### Когда фрагментация становится проблемой?

- Если в [[Heap (Область Памяти)||куче]] образуются “дырки”, а [[Сборщик Мусора (Garbage Collector, GC)||GC]] не успевает их сжимать.
- При работе с большими объектами (особенно в старом поколении [[Heap (Область Памяти)||heap]]), когда не удаётся найти достаточно крупный непрерывный блок памяти.
- Если приложение работает с очень большим объёмом аллокаций, но плохо управляет [[Сборщик Мусора (Garbage Collector, GC)||сборкой мусора]].


### Как избежать проблем с фрагментацией?

- Использовать подходящий [[Сборщик Мусора (Garbage Collector, GC)||GC]] (например, [[G1 GC||G1]] или [[ZGC||ZGC]] для больших приложений с низкими паузами).
- Оптимизировать аллокации (избегать ненужного создания больших [[Объект (Object)||объектов]]).
- Тюнить параметры [[Виртуальная Машина Java (Java Virtual Machine, JVM)||JVM]] (`-XX:+UseG1GC`, `-XX:InitiatingHeapOccupancyPercent`, `-XX:SurvivorRatio` и т. д.).


Фрагментация памяти — это обычное явление, но современные [[Сборщик Мусора (Garbage Collector, GC)||GC]] в Java достаточно эффективны в её устранении.