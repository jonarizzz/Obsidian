В Java, `HashMap` — это структура данных, которая реализует интерфейс [[{TODO} Map (интерфейс)||Map]]. Она представляет собой коллекцию пар “ключ-значение”, где каждый ключ ассоциируется с определенным значением. Основной особенностью `HashMap` является использование [[Хэш-таблица (Hash Table)||хэш-таблицы]] для быстрого поиска, добавления и удаления элементов.

### Принцип работы

1. [[Хэширование (Хэш-функция, Hash Function, Hashing)||Хэширование]] – у ключа вызывается метод hashCode(): 
``` java
int hashCode = key.hashCode();
```
1. [[Хэширование (Хэш-функция, Hash Function, Hashing)||Хэш-функция]] для распределения – в классе HashMap используется дополнительная хэш-функция для уменьшения коллизий и равномерного распределения. Это делается с помощью операции [[Побитовые Операции в Java||XOR и побитового сдвига]]:  
``` java
int hash = hashCode ^ (hashCode >>> 16);
```
2. Вычисление индекса – индекс для таблицы определяется с использованием остатка от деления на размер массива (но чаще это делается с помощью [[Побитовые Операции в Java||побитового И]]): 
``` java
int index = hash & (table.length - 1);
```
3. Размещение – в зависимости от индекса объект помещается в соответствующий бакет массива.
4. Коллизии – если два ключа имеют одинаковый хеш-код элементы объединяются в [[Односвязный список (Singly Linked List)||связный список]] в рамках одного бакета. С Java 8, если количество элементов в бакете превышает определённый порог (8 элементов), [[Односвязный список (Singly Linked List)||связный список]] преобразуется в [[Красно-чёрное дерево (Red-Black Tree)||красно-чёрное дерево]] для ускорения поиска. Элементы в них сравниваются по `equals()`

### Коэффициент загрузки

Коэффициент загрузки в HashMap — это отношение количества элементов к ёмкости карты. Когда он достигает заданного порога (по умолчанию 0.75), ёмкость удваивается, чтобы снизить количество коллизий и поддерживать быструю работу.

### Сложность

Добавление, удаление, поиск:
- В лучшем случае = $O(1)$
- В худшем случае = $O(n)$
- При достижении коллизией порога и превращении [[Односвязный список (Singly Linked List)||связного списка]] в [[Красно-чёрное дерево (Red-Black Tree)||красно-чёрное дерево]] = $O(\log n)$

### Память

$O(n + k \cdot s)$

где:
- $n$  — размер массива корзин (зависит от начальной ёмкости и коэффициента загрузки).
- $k$  — количество элементов в HashMap.
- $s$  — средний размер одного узла (включая ключ, значение и ссылки).