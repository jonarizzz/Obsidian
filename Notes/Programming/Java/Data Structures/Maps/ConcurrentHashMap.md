ConcurrentHashMap — это коллекция из пакета `java.util.concurrent`, предназначенная для работы в [[Многопоточное Программирование (Многопоточка, Multithreading)||многозадачной среде]]. Она обеспечивает конкурентный доступ к данным, позволяя нескольким потокам безопасно читать и записывать данные без необходимости блокировки всего [[Словарь (Map)||словаря]] (как в случае с обычной [[HashMap||HashMap]], которая не потокобезопасна).

### Внутреннее устройство

1. **Разбиение на сегменты (buckets)**: В отличие от [[HashMap||HashMap]], который использует одну структуру для всех элементов, ConcurrentHashMap делит словарь на несколько частей (или “сегментов”). Каждый сегмент обрабатывает определённую часть данных и может быть заблокирован отдельно. Это позволяет улучшить производительность при многозадачности, так как разные потоки могут одновременно работать с разными сегментами словаря.

2. **Механизм блокировки (Locking)**: Для каждого сегмента используется отдельная блокировка, обычно с использованием [[{TODO} ReentrantLock]]. Это означает, что если один поток изменяет данные в одном сегменте, другие потоки могут работать с другими сегментами параллельно без блокировки всего словаря.

3. **Поддержка атомарных операций**: ConcurrentHashMap использует атомарные операции для таких операций, как добавление или удаление элементов, что позволяет избежать проблем, связанных с синхронизацией.

4. **Поддержка операций с итераторами**: Итераторы в ConcurrentHashMap работают без блокировки всей коллекции, предоставляя доступ к данным во время их изменений другими потоками. При этом итератор будет видеть только те изменения, которые были сделаны до начала итерации.

5. **Механизм размытия (rehashing)**: Как и в обычных [[HashMap]], ConcurrentHashMap может использовать динамическое увеличение размера, когда нагрузка на словарь становится слишком большой. Однако, в отличие от [[HashMap]], `rehashing` в ConcurrentHashMap не блокирует весь [[Словарь (Map)||словарь]], а происходит постепенно, улучшая производительность.

6. **Чтение без блокировки**: Для операций чтения карта использует механизм без [[Блокировки (Locking)||блокировки]] (read-write lock), что позволяет многим потокам читать данные одновременно, если они не изменяются. Это значительное улучшение по сравнению с традиционными [[Словарь (Map)||словарями]], где все операции могут требовать [[Синхронизация Потоков (synchronized)||синхронизации]].

### Основные особенности

- **Конкурентность**: Обеспечивает безопасную работу с данными в многозадачной среде без необходимости синхронизировать доступ ко всему словарю.
- **Высокая производительность**: Многопоточные операции (чтение, запись) выполняются эффективно за счет разделения словаря на сегменты и использования отдельных блокировок.
- **Атомарные операции**: Поддержка таких операций, как putIfAbsent, remove, replace, что упрощает реализацию потокобезопасных алгоритмов.


### Ограничения

7. **Не поддерживает null** в качестве ключей и значений.
8. **Не гарантирует порядок элементов** при итерации, так как данные могут изменяться другими потоками.
9. **Операции не атомарны для нескольких ключей** — операции, затрагивающие несколько ключей, требуют дополнительной синхронизации.
10. **Блокировки сегментов** не устраняют блокировку при интенсивных записях, что может снижать производительность.
11. **Итераторы** могут пропустить или дублировать элементы при изменениях другими потоками.
12. **Не поддерживает операции с несколькими значениями** (например, putAll).