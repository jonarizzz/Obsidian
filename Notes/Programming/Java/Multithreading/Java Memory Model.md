
**Java Memory Model (JMM)** определяет, как [[Поток (Thread)||потоки]] взаимодействуют с переменными в памяти, особенно в [[Многопоточное Программирование (Многопоточка, Multithreading)||многопоточной среде]]. Она регламентирует порядок чтения и записи в память, гарантии видимости и [[Атомарность (Atomacy)||атомарности]] операций.

### Основные концепции JMM

- Хранилище данных:
	- Основная память (main memory) — общая память, где хранятся переменные.
	- Локальные [[{TODO} Кэш (Cache)||кэши]] (thread-local cache) — каждый поток может загружать копии переменных в локальные кэши (например, в регистры процессора).
- Взаимодействие потоков с памятью:
	- [[Поток (Thread)||Потоки]] читают и пишут переменные через [[{TODO} Кэш (Cache)||кэши]] и основную память.
	- Без специальных механизмов возможны [[Гонки Данных (Data Races)||гонки данных]] (data races), когда один [[Поток (Thread)||поток]] изменяет переменную, а другой видит устаревшее значение.
- Reordering (перестановка инструкций):
	- [[Виртуальная Машина Java (Java Virtual Machine, JVM)||JVM]] и процессор могут менять порядок выполнения инструкций для оптимизации.
	- Это может привести к неожиданному поведению в [[Многопоточное Программирование (Многопоточка, Multithreading)||многопоточных приложениях]].

### Ключевые гарантии JMM

- Видимость изменений между [[Поток (Thread)||потоками]]:
	- Использование [[volatile||volatile]] гарантирует, что изменения переменной будут видны всем [[Поток (Thread)||потокам]] сразу после записи.
	- Синхронизация ([[Синхронизация Потоков (synchronized)||synchronized]]) также обеспечивает видимость, так как все изменения перед выходом из блока [[Синхронизация Потоков (synchronized)||synchronized]] записываются в основную память.
- [[Атомарность (Atomacy)||Атомарность]] операций:
	- Чтение и запись [[Примитивные Типы Данных (Primitives)||примитивных типов]] до 64 бит (кроме [[long||long]] и [[double||double]] в старых версиях Java) [[Атомарность (Atomacy)||атомарны]].
	- Для сложных операций (например, i++) нужна [[Синхронизация Потоков (synchronized)||синхронизация]] или [[AtomicInteger||AtomicInteger]].
- Упорядоченность операций:
	- JMM вводит [[Happens Before||happens-before]] отношение, которое определяет корректный порядок выполнения операций.


### [[Happens Before||Happens-before]] правила

JMM гарантирует, что если одна операция [[Happens Before||happens-before]] другой, то первая операция будет видна и упорядочена перед второй.

### Основные правила:

- Блок [[Синхронизация Потоков (synchronized)||synchronized]]: выход из [[Синхронизация Потоков (synchronized)||synchronized]] блока одним потоком [[Happens Before||happens-before]] входом в этот же блок другим потоком.
- [[volatile||volatile]] переменные: запись в [[volatile||volatile]] переменную [[Happens Before||happens-before]] последующим чтением этой переменной.
- Инициализация [[Объект (Object)||объекта]]: конструктор объекта [[Happens Before||happens-before]] его использованием в другом [[Поток (Thread)||потоке]].
- `Thread.start()` и `Thread.join()`: вызов `start()` потока [[Happens Before||happens-before]] кодом внутри него, а `join()` [[Happens Before||happens-before]] завершением [[Поток (Thread)||потока]].

### Как избежать проблем с JMM

- Используйте [[volatile||volatile]], когда нужна гарантия видимости.
- Применяйте [[Синхронизация Потоков (synchronized)||synchronized]] для защиты критических секций.
- Используйте классы из `java.util.concurrent` ([[AtomicInteger||AtomicInteger]], [[ConcurrentHashMap||ConcurrentHashMap]]).
- Избегайте ненужных [[Блокировки (Locking)||блокировок]], чтобы не снижать производительность.

  
