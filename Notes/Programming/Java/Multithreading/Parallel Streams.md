**Parallel Streams** в Java — это мощный инструмент, позволяющий обрабатывать данные в коллекциях параллельно, используя несколько потоков. Они основаны на [[{TODO} Stream API||Stream API]] и встроенных механизмах параллелизма из [[Fork Join Framework||ForkJoinPool]]. Parallel Streams автоматически распределяют задачи между потоками, упрощая написание параллельных вычислений.


## Ключевые особенности:

1. **Параллельная обработка:**
   Вместо последовательной обработки (один за другим), задачи выполняются параллельно.
   
1. **Модель Fork/Join:**
   Parallel Streams используют пул потоков (`ForkJoinPool.commonPool`) для деления задач на подзадачи и их выполнения.

3. **Легкость использования:**
   Вы можете конвертировать обычный стрим в параллельный, вызвав метод `.parallelStream()` на коллекции или `.parallel()` на обычном стриме.

4. **Подходит для CPU-bound задач:**
   Эффективен, когда операции требуют интенсивных вычислений и хорошо делятся на независимые части.


## Имплементация

``` java
import java.util.List;
import java.util.stream.IntStream;

// Пример сравнения производительности

public class PerformanceTest {
    public static void main(String[] args) {
        List<Integer> numbers = IntStream.rangeClosed(1, 10_000_000)
			 .boxed()
			 .toList();
			
        // Sequential Stream
        long start = System.currentTimeMillis();
        numbers.stream().reduce(0, Integer::sum);
        long end = System.currentTimeMillis();
        System.out.println("Sequential Time: " + (end - start) + "ms");
		
        // Parallel Stream
        start = System.currentTimeMillis();
        numbers.parallelStream().reduce(0, Integer::sum);
        end = System.currentTimeMillis();
        System.out.println("Parallel Time: " + (end - start) + "ms");
    }
}
```


## Контроль над количеством потоков:

По умолчанию Parallel Streams используют общий пул потоков `ForkJoinPool.commonPool`, который имеет количество потоков, равное числу ядер процессора. Если нужно изменить это поведение, можно задать системное свойство:

``` java
System.setProperty("java.util.concurrent.ForkJoinPool.common.parallelism", "4");
```

Или создать свой пул потоков:

``` java
ForkJoinPool customPool = new ForkJoinPool(4);
customPool.submit(() -> numbers.parallelStream().forEach(System.out::println));
customPool.shutdown();
```


## Когда использовать Parallel Streams

1. **Большие объемы данных:**
   Для обработки больших коллекций параллельные стримы могут значительно ускорить выполнение.

2. **Независимые операции:**
   Если каждая операция в стриме может быть выполнена независимо от других (например, вычисления на отдельных элементах).

3. **Многоядерные процессоры:**
   Parallel Streams особенно полезны, когда ваш процессор имеет несколько ядер и есть возможность распараллеливания.


## Когда не стоит использовать Parallel Streams

1. **Маленькие коллекции:**
   Накладные расходы на управление потоками могут перевесить преимущества параллелизма.

2. **IO-bound задачи:**
   Если операции включают чтение/запись из/в файловую систему или сеть, параллельность может не дать прироста производительности.

3. **Сложные операции с состоянием:**
   Если операции зависят друг от друга или изменяют общее состояние, это может привести к ошибкам или снижению производительности.

4. **Неоптимальные источники данных:**
   Источники с неопределенным или плохо разрезаемым объемом данных (например, [[LinkedList||LinkedList]]) могут быть неэффективны для параллельной обработки.


## Плюсы Parallel Streams

1. Простота написания кода.

2. Автоматическое управление потоками.

3. Высокая производительность для больших объемов данных.


## Минусы

1. Меньший контроль над потоками.

2. Потенциальные проблемы с порядком обработки.

3. Может быть сложным для отладки.