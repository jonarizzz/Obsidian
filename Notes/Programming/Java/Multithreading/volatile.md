
**volatile** — это модификатор (ключевое слово), который применяется к переменным для обеспечения видимости их изменений в [[Многопоточное Программирование (Многопоточка, Multithreading)||многопоточной среде]].

### Основные свойства:

- Гарантия видимости: Если один [[Поток (Thread)||поток]] изменяет `volatile` переменную, другие [[Поток (Thread)||потоки]] немедленно увидят это изменение.
- Запрет [[{TODO} Кэш (Cache)||кэширования]]: Значение `volatile` переменной всегда читается из основной памяти, а не из кэша процессора или потокового контекста.
- Отсутствие [[Атомарность (Atomacy)||атомарности]]: `volatile` лишь указывает откуда читать значение и что его могут изменить другие [[Поток (Thread)||потоки]], он не обеспечивает ни [[Синхронизация Потоков (synchronized)||синхронизации]], ни [[Атомарность (Atomacy)||атомарности]]. 


### Что можно объявить volatile:

- [[Примитивные Типы Данных (Primitives)||Примитивные типы]] (int, long, boolean и т. д.)
- [[Ссылочный Тип Данных (Сильная Ссылка, Strong Reference, Link)||Ссылки на объекты]] (`volatile MyClass obj;`), но не [[Объект (Object)||сами объекты]]!

### Важно:

- `volatile` гарантирует, что [[Ссылочный Тип Данных (Сильная Ссылка, Strong Reference, Link)||ссылка]] на объект будет актуальной во всех [[Поток (Thread)||потоках]].
- Но он не делает поля объекта [[Атомарность (Atomacy)||атомарными]].

### Что нельзя объявить volatile:

- Поля внутри [[Объект (Object)||объекта]] (`volatile` работает только на уровне переменной, а не её содержимого).
- Операции с несколькими переменными (`volatile` не обеспечивает [[Атомарность (Atomacy)||атомарность]] сложных операций).


### Пример использования:

```java
class SharedResource {
    volatile boolean running = true;
    
    void stop() {
        running = false; // Изменение переменной сразу будет видно в других потоках
    }
}

public class VolatileExample {
    public static void main(String[] args) {
        SharedResource resource = new SharedResource();
        
        Thread thread = new Thread(() -> {
            while (resource.running) {
                // Бесконечный цикл, если не использовать volatile
            }
            System.out.println("Поток завершился");
        });
		
        thread.start();
		
        try {
            Thread.sleep(1000); // Даем потоку время запуститься
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
		
        resource.stop(); // Без volatile поток мог бы не увидеть изменения
    }
}
```


### Когда использовать volatile:

- Когда несколько [[Поток (Thread)||потоков]] читают и пишут в переменную.
- Когда важна синхронизация изменений без блокировки ([[Синхронизация Потоков (synchronized)||synchronized]]).
- Когда переменная обновляется отдельно, а не как часть сложной операции.


### Когда не подходит:

- Если нужна [[Атомарность (Atomacy)||атомарность]] операций ([[AtomicInteger||AtomicInteger]], [[Синхронизация Потоков (synchronized)||synchronized]]).
- Если требуется гарантия порядка выполнения (используй [[Синхронизация Потоков (synchronized)||synchronized]]).
