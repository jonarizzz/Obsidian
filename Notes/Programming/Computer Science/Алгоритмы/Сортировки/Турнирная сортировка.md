Турнирная сортировка — это метод сортировки, основанный на организации данных в виде бинарного дерева, которое моделирует процесс соревнования (турнира). На каждом этапе элементы сравниваются, и победитель (меньший элемент в случае сортировки по возрастанию) переходит на следующий уровень. Основная идея заключается в том, чтобы сначала сформировать дерево победителей, а затем извлекать минимальный элемент, обновляя дерево.

1. **Инициализация**: 
	1. Построение дерева турнира, где на листовых узлах находятся элементы массива.
	2. Каждый внутренний узел хранит победителя (минимум или максимум) среди его дочерних узлов.
2. **Извлечение минимального элемента**:
	1. Корень дерева хранит текущий минимальный элемент.
	2. После извлечения минимального элемента обновляется значение в дереве, и процесс повторяется.
3. **Обновление**:
	1. Элемент, только что извлеченный из дерева, заменяется на “бесконечность” (или другое значение, чтобы он больше не участвовал в турнире).
	2. Перестраивается только та часть дерева, где произошло изменение.


**Имплементация:**

```
import java.util.Arrays;

public class TournamentSort {
    // Метод сортировки
    public static void tournamentSort(int[] arr) {
        int n = arr.length;
        int[] tree = new int[2 * n - 1]; // Турнирное дерево
        int offset = n - 1; // Смещение для индексов листьев
		
        // Построение дерева
        System.arraycopy(arr, 0, tree, offset, n); // Копируем массив в листья дерева
        for (int i = offset - 1; i >= 0; i--) {
            tree[i] = Math.min(tree[2 * i + 1], tree[2 * i + 2]); // Узлы хранят минимум
        }
		
        // Извлечение элементов
        for (int i = 0; i < n; i++) {
            arr[i] = tree[0]; // Минимум всегда в корне
            replaceWinner(tree, arr[i], offset); // Обновление дерева
        }
    }
	
    // Замена победителя на "бесконечность" и перестройка дерева
    private static void replaceWinner(int[] tree, int value, int offset) {
        int index = 0;
        while (index < offset) { // Найти лист, содержащий значение
            int left = 2 * index + 1;
            int right = 2 * index + 2;
            index = (tree[left] == value) ? left : right;
        }
        tree[index] = Integer.MAX_VALUE; // Заменить на бесконечность
		
        // Перестроение дерева
        index = (index - 1) / 2;
        while (index >= 0) {
            tree[index] = Math.min(tree[2 * index + 1], tree[2 * index + 2]);
            if (index == 0) break; // Достигли корня
            index = (index - 1) / 2;
        }
    }
	
    // Тестирование
    public static void main(String[] args) {
        int[] arr = {8, 4, 7, 3, 2, 6, 5, 1};
        System.out.println("Исходный массив: " + Arrays.toString(arr));
        tournamentSort(arr);
        System.out.println("Отсортированный массив: " + Arrays.toString(arr));
    }
}
```


**Временная сложность:**

- **Построение дерева турнира**:  $O(n)$ , где  n  — количество элементов.
- **Каждое извлечение элемента**:  $O(\log n)$  для обновления дерева.
- Для сортировки всех элементов требуется  $O(n \log n)$  извлечений.
- **Общая сложность**:  $O(n + n \log n)  ≈  O(n \log n)$ .


**Затраты по памяти**

- Требуется дополнительное место для хранения дерева турнира.
- Размер дерева:  $2n - 1$  узлов для полного бинарного дерева, где  n  — число элементов.
- Итоговая память:  $O(n)$  для хранения исходного массива и дерева.