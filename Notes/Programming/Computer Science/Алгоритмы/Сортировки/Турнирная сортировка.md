Турнирная сортировка — это алгоритм сортировки, который работает по принципу турнирного дерева. Этот метод схож с отбором победителя в спортивном турнире: элементы сравниваются попарно, победитель каждого сравнения (то есть наименьший или наибольший элемент) проходит на следующий уровень, пока не будет найден окончательный победитель. Затем процесс повторяется для оставшихся элементов, чтобы найти второй, третий и так далее элементы в отсортированном порядке.

1. **Создание турнирного дерева**: элементы массива размещаются в виде листьев дерева, причем каждый узел дерева хранит результат “матча” между двумя дочерними элементами.
2. **Построение иерархии**: происходит последовательное сравнение элементов, в каждом узле записывается “победитель” матча, и так до корня, в котором находится победитель всего дерева — наименьший или наибольший элемент массива.
3. **Обновление и перестроение дерева**: после нахождения победителя его значение заменяется значением “побежденного” элемента из поддерева, и “турнир” повторяется с учетом новых данных. Этот процесс продолжается, пока все элементы не будут “перемещены” в отсортированный список.


**Имплементация:**

```
import java.util.Arrays;

public class TournamentSort {
    
    public static void tournamentSort(int[] array) {
        int n = array.length;
        int[] tree = new int[2 * n - 1];
        
        // Заполняем листья дерева значениями массива
        for (int i = 0; i < n; i++) {
            tree[n - 1 + i] = array[i];
        }

        // Построение турнирного дерева
        for (int i = n - 2; i >= 0; i--) {
            tree[i] = Math.min(tree[2 * i + 1], tree[2 * i + 2]);
        }

        // Извлечение минимальных элементов и замена их на Integer.MAX_VALUE
        for (int i = 0; i < n; i++) {
            array[i] = tree[0]; // корень дерева - минимальный элемент
            
            // Найдем и заменим минимальный элемент в дереве
            int index = findAndReplace(tree, 0, tree[0], Integer.MAX_VALUE);
            
            // Перестраиваем дерево после замены
            while (index > 0) {
                index = (index - 1) / 2;
                tree[index] = Math.min(tree[2 * index + 1], tree[2 * index + 2]);
            }
        }
    }
    
    private static int findAndReplace(int[] tree, int index, int target, int replacement) {
        // Находим целевой элемент и заменяем его
        if (index >= tree.length) return -1;
        if (tree[index] == target) {
            tree[index] = replacement;
            return index;
        }
        
        int leftIndex = findAndReplace(tree, 2 * index + 1, target, replacement);
        if (leftIndex != -1) return leftIndex;
        
        return findAndReplace(tree, 2 * index + 2, target, replacement);
    }
    
    public static void main(String[] args) {
        int[] array = {5, 3, 8, 6, 2, 7, 4, 1};
        System.out.println("Original array: " + Arrays.toString(array));
        
        tournamentSort(array);
        
        System.out.println("Sorted array:   " + Arrays.toString(array));
    }
}
```


**Сложность:**

Временная сложность:
- Построение турнирного дерева занимает O(n) операций.
- Перестроение дерева и нахождение “победителя” после каждого этапа занимает O(\log n) операций.
- Итоговая сложность — O(n \log n), как и у многих других сортировок.

Пространственная сложность:
- Память для хранения исходного массива: требуется O(n) памяти, чтобы хранить все элементы, которые нужно отсортировать.
- Память для турнирного дерева: турнирное дерево представляет собой бинарное дерево с n листьями (для n элементов массива) и требует дополнительной памяти для хранения узлов. Полное турнирное дерево для n элементов включает примерно 2n - 1 узлов, что также является O(n).
- Таким образом, общая сложность по памяти составляет O(n) — линейная по количеству сортируемых элементов.