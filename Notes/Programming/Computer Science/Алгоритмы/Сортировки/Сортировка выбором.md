
**Механизм:**
1. В неотсортированном подмассиве ищется локальный максимум (минимум).
2. Найденный максимум (минимум) меняется местами с последним (первым) элементом в подмассиве.
3. Если в массиве остались неотсортированные подмассивы — смотри пункт 1.

![[Сортировка выбором.gif]]


**Имплементация:**

```
void SelectionSort(vector<int>& values) { 
	for (auto i = values.begin(); i != values.end(); ++i) { 
		auto j = std::min_element(i, values.end()); 
		swap(*i, *j); 
	} 
}
```

**Сложность:**

**Временная сложность:**

1. **В худшем случае**: $O(n^2)$ 
   Чтобы найти минимальный элемент, алгоритму требуется один проход по массиву ($O(n)$). Этот процесс повторяется для каждого из n элементов, давая суммарную сложность $O(n^2)$.

2. **В среднем случае**: $O(n^2)$ 
   Алгоритм всегда выполняет одинаковое количество операций независимо от исходного порядка элементов, так как минимальный элемент приходится искать каждый раз.

3. **В лучшем случае**: $O(n^2)$ 
   Даже если массив уже отсортирован, алгоритм всё равно выполнит $O(n^2)$ сравнений, так как он проходит по всем оставшимся элементам, чтобы найти минимальный.

**Пространственная сложность:**

Сортировка выбором выполняется **in-place**, то есть не использует дополнительную память: $O(1)$

Требуется только несколько переменных для хранения индексов и временной переменной для обмена элементов.