
Сортировка слиянием — это алгоритм **разделяй и властвуй**, который рекурсивно делит массив на подмассивы, сортирует их и затем сливает (объединяет) в один отсортированный массив.

1. **Разделение**: Массив рекурсивно делится пополам, пока не станет из отдельных элементов (размер подмассива = 1, а одиночный элемент всегда отсортирован).
2. **Слияние**: 
	1. После того как массивы разбиты до одного элемента, начинается их слияние.
	2. Два отсортированных подмассива объединяются в один, соблюдая порядок сортировки.


![[Сортировка слиянием.gif]]



**Имплементация:**

```
import java.util.Arrays;

public class MergeSort {

    // Основной метод сортировки слиянием
    public static void mergeSort(int[] array) {
        if (array.length < 2) {
            return; // Массив уже отсортирован
        }
		
        // Разделяем массив на две половины
        int mid = array.length / 2;
        int[] left = Arrays.copyOfRange(array, 0, mid);
        int[] right = Arrays.copyOfRange(array, mid, array.length);
		
        // Рекурсивная сортировка двух частей
        mergeSort(left);
        mergeSort(right);
		
        // Слияние отсортированных частей
        merge(array, left, right);
    }
	
    // Метод для слияния двух отсортированных массивов
    private static void merge(int[] array, int[] left, int[] right) {
        int i = 0, j = 0, k = 0;
		
        // Пока есть элементы в обоих массивах
        while (i < left.length && j < right.length) {
            if (left[i] <= right[j]) {
                array[k++] = left[i++];
            } else {
                array[k++] = right[j++];
            }
        }
		
        // Копируем оставшиеся элементы из левого массива (если есть)
        while (i < left.length) {
            array[k++] = left[i++];
        }
		
        // Копируем оставшиеся элементы из правого массива (если есть)
        while (j < right.length) {
            array[k++] = right[j++];
        }
    }
	
    public static void main(String[] args) {
        int[] array = {8, 3, 7, 4, 6, 2, 5, 1};
        System.out.println("Before sorting: " + Arrays.toString(array));
        mergeSort(array);
        System.out.println("After sorting: " + Arrays.toString(array));
    }
}
```


**Временная сложность:**

1. **Разделение массива**: Разделение выполняется рекурсивно на каждом уровне, что занимает $O(\log n)$.
2. **Слияние**: На каждом уровне объединяются элементы всех подмассивов, что занимает $O(n)$ на уровне.
3. **Итоговая сложность**: На каждом уровне выполняется $O(n)$, а уровней $\log n$, поэтому: $O(n \log n)$
4. **Лучший, худший и средний случаи**:

Поскольку операции разделения и слияния всегда одинаковы, сложность остаётся $O(n \log n)$ для всех случаев.


**Пространственная сложность**:

1. **Дополнительная память**: Для слияния требуется дополнительный массив, размер которого равен размеру сортируемой части, поэтому $O(n)$.
2. **Для рекурсии**: Глубина стека вызовов рекурсии равна $\log n$, что добавляет $O(\log n)$.
3. **Итоговая пространственная сложность**: $O(n)$