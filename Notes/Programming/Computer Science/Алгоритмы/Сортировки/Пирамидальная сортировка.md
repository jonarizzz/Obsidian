При этой сортировке сначала строится пирамида из элементов исходного массива. Пирамида (или двоичная куча) — это способ представления элементов, при котором от каждого узла может отходить не больше двух ответвлений. А значение в родительском узле должно быть больше значений в его двух дочерних узлах.

![[Пирамидальная сортировка.gif]]

Пирамидальная сортировка похожа на сортировку выбором, где мы сначала ищем максимальный элемент, а затем помещаем его в конец. Дальше нужно рекурсивно повторять ту же операцию для оставшихся элементов.

![[Пирамидальная сортировка 2.gif]]

1. **Построение кучи**:
   Преобразовать массив в **макс-кучу**. Это обеспечивает, что на вершине кучи (в корне дерева) находится наибольший элемент.

2. **Извлечение максимального элемента**:
	1. Меняем местами корневой элемент (наибольший) с последним элементом массива.
	2. Сокращаем размер кучи (чтобы исключить уже отсортированный элемент).
	3. Восстанавливаем структуру кучи для оставшихся элементов.

3. Повторяем шаг 2, пока в куче остаётся больше одного элемента.


**Имплементация:**

```
import java.util.Arrays;

public class HeapSort {
    public static void heapSort(int[] array) {
        int n = array.length;

        // Построение кучи
        for (int i = n / 2 - 1; i >= 0; i--) {
            heapify(array, n, i);
        }

        // Извлечение элементов из кучи
        for (int i = n - 1; i > 0; i--) {
            // Перемещаем корень (максимальный элемент) в конец массива
            int temp = array[0];
            array[0] = array[i];
            array[i] = temp;

            // Восстанавливаем кучу для оставшихся элементов
            heapify(array, i, 0);
        }
    }

    // Восстановление свойства кучи
    private static void heapify(int[] array, int size, int root) {
        int largest = root; // Инициализируем корень как наибольший
        int left = 2 * root + 1; // Левый потомок
        int right = 2 * root + 2; // Правый потомок

        // Если левый потомок больше корня
        if (left < size && array[left] > array[largest]) {
            largest = left;
        }

        // Если правый потомок больше текущего наибольшего
        if (right < size && array[right] > array[largest]) {
            largest = right;
        }

        // Если наибольший элемент не корень
        if (largest != root) {
            int temp = array[root];
            array[root] = array[largest];
            array[largest] = temp;

            // Рекурсивно восстанавливаем кучу
            heapify(array, size, largest);
        }
    }

    public static void main(String[] args) {
        int[] array = {4, 10, 3, 5, 1};
        System.out.println("Before sorting: " + Arrays.toString(array));

        heapSort(array);
        System.out.println("After sorting: " + Arrays.toString(array));
    }
}
```

**Сложность:**

1. **Построение кучи**: Построение кучи выполняется за время $O(n)$.

2. **Перестроение кучи (heapify)**: После извлечения максимального элемента требуется $O(\log n)$ операций для восстановления свойств кучи. Этот процесс повторяется n - 1 раз, так что сложность составляет: $O(n \log n)$

3. **Итоговая сложность**: $O(n \log n)$
   Это верно как для худшего, так и для среднего и лучшего случаев.


**Пространственная сложность:**

Пирамидальная сортировка выполняется **in-place** (встроенно), так как для реализации кучи используется исходный массив. $O(1)$