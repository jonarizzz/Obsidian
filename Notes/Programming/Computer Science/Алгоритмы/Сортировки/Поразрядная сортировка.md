Поразрядная сортировка (или **radix sort**) — это алгоритм сортировки, который сортирует элементы по разрядам их числовых значений. Этот алгоритм особенно эффективен для сортировки целых чисел или строк с одинаковой длиной. Он работает не напрямую с самими числами, а с их разрядами (цифрами или символами), что позволяет обрабатывать элементы поочередно.

Основные этапы алгоритма:
1. Определение разряда: Для каждого числа (или строки) определяется разряд, с которого будет начинаться сортировка (например, для чисел — с младшего разряда, для строк — с первого символа).
2. Сортировка по разряду: Все числа (или строки) сортируются по текущему разряду. Это можно сделать с помощью стабильной сортировки, например, с использованием сортировки подсчётом ([[Сортировка подсчётом]]).
3. Переход к следующему разряду: После того как все элементы отсортированы по текущему разряду, переходят к следующему разряду и повторяют процесс.
4. Завершение: Алгоритм повторяет этот процесс до тех пор, пока не будут обработаны все разряды.


**Имплементация:**

```
import java.util.Arrays;

public class RadixSort {

    // Метод для выполнения сортировки по разрядам
    public static void radixSort(int[] arr) {
        // Находим максимальное число в массиве
        int max = Arrays.stream(arr).max().getAsInt();

        // Проходим по всем разрядам, начиная с младшего
        for (int exp = 1; max / exp > 0; exp *= 10) {
            countingSortByDigit(arr, exp);
        }
    }

    // Сортировка по разряду, используя сортировку подсчётом
    private static void countingSortByDigit(int[] arr, int exp) {
        int n = arr.length;
        int[] output = new int[n]; // Массив для хранения отсортированных значений
        int[] count = new int[10]; // Счётчики для цифр от 0 до 9

        // Подсчитываем количество встречающихся цифр
        for (int i = 0; i < n; i++) {
            count[(arr[i] / exp) % 10]++;
        }

        // Изменяем count[i], так чтобы count[i] содержал 
        // фактическую позицию цифры в output[]
        for (int i = 1; i < 10; i++) {
            count[i] += count[i - 1];
        }

        // Строим отсортированный массив, обрабатывая элементы с конца, чтобы сохранить стабильность сортировки
        for (int i = n - 1; i >= 0; i--) {
            int digit = (arr[i] / exp) % 10;
            output[count[digit] - 1] = arr[i];
            count[digit]--;
        }

        // Копируем отсортированные элементы обратно в исходный массив
        System.arraycopy(output, 0, arr, 0, n);
    }

    // Пример использования
    public static void main(String[] args) {
        int[] arr = {170, 45, 75, 90, 802, 24, 2, 66};
        System.out.println("Исходный массив: " + Arrays.toString(arr));

        radixSort(arr);

        System.out.println("Отсортированный массив: " + Arrays.toString(arr));
    }
}
```


**Сложность:**

Сложность по времени:
- Лучший, средний и худший случаи: O(nk), где n — количество элементов, а k — количество разрядов (или длина чисел/строк). Если k фиксировано, сложность считается почти линейной O(n).

Сложность по памяти:
- O(n + k), где n — количество элементов, а k — количество разрядов. Дополнительная память требуется для хранения промежуточных данных при сортировке по каждому разряду.