**Алгоритм Кнута-Морриса-Пратта (КМП)** предназначен для эффективного поиска подстроки (образца) в строке. Его основная идея заключается в том, чтобы избежать повторного сравнения символов, уже проверенных ранее.


### Алгоритм

1. Предварительная обработка образца:
	1. Построение массива префикс-функции (или массива отказов). Этот массив хранит информацию о совпадении префиксов и суффиксов образца, что позволяет сократить число проверок.
	2. Если происходит несоответствие символов, алгоритм использует префикс-функцию, чтобы переместить образец, сохранив уже совпавшие символы.
2. Основной поиск:
	1. Сравниваются символы строки и образца. В случае несоответствия префикс-функция указывает, сколько символов можно пропустить.


### Сложность

- **Предварительная обработка:**  $O(m)$ , где  $m$  — длина образца.
- **Поиск:**  $O(n)$ , где  $n$  — длина строки.
- Общая сложность:  $O(n + m)$.


### Имплементация

``` java
public class KMPAlgorithm {
    // Построение префикс-функции
    private static int[] computePrefixFunction(String pattern) {
        int m = pattern.length();
        int[] prefix = new int[m];
        int j = 0;
        for (int i = 1; i < m; i++) {
            while (j > 0 && pattern.charAt(i) != pattern.charAt(j)) {
                j = prefix[j - 1];
            }
            if (pattern.charAt(i) == pattern.charAt(j)) {
                j++;
            }
            prefix[i] = j;
        }
        return prefix;
    }
	
    // Реализация поиска
    public static void search(String text, String pattern) {
        int n = text.length();
        int m = pattern.length();
        int[] prefix = computePrefixFunction(pattern);
        int j = 0; // Индекс в образце
        for (int i = 0; i < n; i++) {
            while (j > 0 && text.charAt(i) != pattern.charAt(j)) {
                j = prefix[j - 1];
            }
            if (text.charAt(i) == pattern.charAt(j)) {
                j++;
            }
            if (j == m) {
                System.out.println("Образец найден на позиции " + (i - m + 1));
                j = prefix[j - 1]; // Продолжение поиска
            }
        }
    }
	
    public static void main(String[] args) {
        String text = "ababcababcabc";
        String pattern = "ababc";
        search(text, pattern);
    }
}
```


### Преимущества

- Линеарная сложность делает его эффективным для поиска в больших текстах.
- Подходит для поиска множества подстрок (последовательно).


### Ограничения

- Необходима дополнительная память для хранения префикс-функции.
- Для очень больших текстов в памяти может возникнуть ограничение.