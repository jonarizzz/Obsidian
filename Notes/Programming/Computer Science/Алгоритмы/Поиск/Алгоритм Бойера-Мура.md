**Алгоритм Бойера-Мура** — это один из наиболее эффективных алгоритмов для поиска подстроки в строке, особенно при длинных строках и небольших образцах. Его ключевая идея заключается в использовании эвристик для пропуска символов, что позволяет сократить количество сравнений.


### Основные принципы работы

1. **Эвристика плохого символа:**
   Если символ в строке не совпадает с соответствующим символом образца, алгоритм сдвигает образец так, чтобы несовпавший символ в строке совпал с последним его появлением в образце (или за границу образца, если такого символа нет).
   Сдвиг определяется с помощью заранее построенной таблицы.

2. **Эвристика хорошего суффикса:**
   Если обнаружен частичный суффикс, совпадающий с концом образца, образец сдвигается так, чтобы этот суффикс совпал с другой его позицией в образце (если такая есть), либо чтобы избежать совпадений суффикса.


### Этапы алгоритма

1. **Предобработка:**
	1. Построение таблицы для **плохого символа**.
	2. Построение таблицы для **хорошего суффикса** (опционально, для оптимизации).
2. **Поиск:**
   Алгоритм начинает сравнение символов образца с текстом справа налево. В случае несовпадения используется информация из эвристик для пропуска символов.


### Временная сложность

- **Худший случай:**  $O(n \cdot m)$ , где  $n$  — длина текста,  $m$  — длина образца. Это случается, если текст и образец состоят из одинаковых символов.
- **Средний случай:**  $O(n / m)$ , если символы равномерно распределены.

Алгоритм особенно эффективен при редких совпадениях.


### Имплементация

``` java
import java.util.HashMap;
import java.util.Map;

public class BoyerMoore {
    // Построение таблицы сдвигов для плохого символа
    private static Map<Character, Integer> buildBadCharTable(String pattern) {
        Map<Character, Integer> badCharTable = new HashMap<>();
        int m = pattern.length();
        for (int i = 0; i < m; i++) {
            badCharTable.put(pattern.charAt(i), i);
        }
        return badCharTable;
    }
	
    // Основной метод поиска
    public static void search(String text, String pattern) {
        int n = text.length();
        int m = pattern.length();
        // Построение таблицы плохих символов
        Map<Character, Integer> badCharTable = buildBadCharTable(pattern);
        int shift = 0; // Смещение образца относительно текста
        while (shift <= n - m) {
            int j = m - 1;
            // Сравниваем образец с текстом справа налево
            while (j >= 0 && pattern.charAt(j) == text.charAt(shift + j)) {
                j--;
            }
            if (j < 0) {
                // Образец найден
                System.out.println("Образец найден на позиции " + shift);
                shift += (shift + m < n) ? m - badCharTable.getOrDefault(text.charAt(shift + m), -1) : 1;
            } else {
                // Смещение на основе плохого символа
                char badChar = text.charAt(shift + j);
                shift += Math.max(1, j - badCharTable.getOrDefault(badChar, -1));
            }
        }
    }
	
    public static void main(String[] args) {
        String text = "abacaabadcabacabaabb";
        String pattern = "abacab";
        search(text, pattern);
    }
}
```


### Преимущества

**Высокая эффективность** при длинных текстах и коротких образцах.
Меньшее число сравнений по сравнению с наивным методом.
Эффективен для текстов с нечастыми совпадениями.


### Недостатки

- Алгоритм сложнее для реализации, особенно с поддержкой эвристики хорошего суффикса.
- Требует предварительной обработки для построения таблиц, что может быть ресурсоёмким для больших алфавитов.