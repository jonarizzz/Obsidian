
**Задача о размене монет** — это классическая задача оптимизации, в которой нужно минимизировать количество монет, необходимых для выдачи определенной суммы. Задача формулируется следующим образом:

**Дано:** Набор монет с фиксированными номиналами  $\{c_1, c_2, …, c_n\}$  и сумма  $S$ .

**Найти:** Минимальное количество монет, необходимое для размена суммы  $S$ , или сообщить, что это невозможно.


## Решение жадным методом:

[[Жадные алгоритмы||Жадный алгоритм]] для этой задачи:
1. На каждом шаге выбираем монету с **наибольшим номиналом**, который не превышает оставшуюся сумму.
2. Вычитаем её номинал из суммы.
3. Повторяем, пока сумма не станет равной нулю.


## Условие применимости жадного метода:

Жадный алгоритм работает оптимально только для **канонических наборов монет**, где наибольший номинал всегда может быть дополнен меньшими номиналами без увеличения количества монет. Например:

- Для набора  $\{1, 5, 10, 25\}$  (как в США) жадный метод всегда работает.
- Для нестандартного набора  $\{1, 3, 4\}$  жадный алгоритм может быть не оптимальным.


## Пример ошибки жадного алгоритма:

Для набора монет  $\{1, 3, 4\}$  и суммы  $S = 6$ :

- Жадный метод выберет  $4 + 1 + 1 = 6$  (3 монеты).
- Оптимальное решение:  $3 + 3 = 6$ (2 монеты).


## Сложность

**Временная сложность**:
$O(n + k)$, где  $n$  — количество монет,  $k$  — количество монет, использованных для размена.
(Сортировка монет  $O(n \log n)$  выполняется один раз.)

**Пространственная сложность**:
$O(k)$ для хранения результата.

## Имплементация

``` java
import java.util.*;

public class CoinChange {
    public static List<Integer> greedyCoinChange(int[] coins, int amount) {
        List<Integer> result = new ArrayList<>();
        Arrays.sort(coins); // Сортируем монеты по возрастанию
        for (int i = coins.length - 1; i >= 0; i--) {
            while (amount >= coins[i]) {
                amount -= coins[i];
                result.add(coins[i]);
            }
        }
        if (amount > 0) {
            throw new IllegalArgumentException("Невозможно разменять сумму с данными монетами.");
        }
        return result;
    }
	
    public static void main(String[] args) {
        int[] coins = {1, 5, 10, 25};
        int amount = 63;
        try {
            List<Integer> result = greedyCoinChange(coins, amount);
            System.out.println("Монеты для размена: " + result);
            System.out.println("Количество монет: " + result.size());
        } catch (IllegalArgumentException e) {
            System.out.println(e.getMessage());
        }
    }
}
```


## Альтернативный подход:

Для решения задачи с гарантией оптимальности можно использовать [[Динамическое программирование]]. Этот метод находит оптимальный размен для любого набора монет, но работает медленнее (временная сложность  $O(S \cdot n)$ , где  $S$  — сумма,  $n$  — количество номиналов).