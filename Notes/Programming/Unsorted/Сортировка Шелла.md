Сортировка Шелла — это усовершенствование сортировки вставками. Она использует идею сравнения элементов, находящихся на определённом расстоянии (так называемый **gap**), которое уменьшается в процессе сортировки. На последнем этапе gap = 1, что сводит алгоритм к обычной сортировке вставками для почти отсортированного массива.
Алгоритм Шелла сочетает простоту реализации и высокую производительность.
Благодаря выбору оптимальных разрывов, он значительно быстрее, чем сортировка вставками на больших массивах.

Невзирая на то, что сортировка Шелла во многих случаях медленнее, чем [[Быстрая сортировка (Quick Sort)]], она имеет ряд преимуществ:

- отсутствие потребности в памяти под стек;
- отсутствие деградации при неудачных наборах данных — быстрая сортировка легко деградирует до $O(n^2)$, что хуже, чем худшее гарантированное время для сортировки Шелла.

**Как работает сортировка Шелла:**
1. **Инициализация разрывов**: Задаётся начальное значение gap, обычно равное половине длины массива. Затем gap уменьшается (например, делением на 2) до 1.
2. **Сортировка по подгруппам**: На каждом этапе элементы массива, находящиеся на расстоянии gap, сравниваются и при необходимости меняются местами.
3. **Сортировка при** gap = 1: Последний этап сортировки является сортировкой вставками для всего массива.


![[Сортировка Шелла.gif]]

**Имплементация:**

```
import java.util.Arrays;

public class ShellSort {
    public static void shellSort(int[] array) {
        int n = array.length;
		
        // Начальный разрыв (gap) — половина длины массива
        for (int gap = n / 2; gap > 0; gap /= 2) {
            // Сортировка по разрывам
            for (int i = gap; i < n; i++) {
                int temp = array[i]; // Текущий элемент
                int j;
				
                // Перемещение элементов, которые больше текущего
                for (j = i; j >= gap && array[j - gap] > temp; j -= gap) {
                    array[j] = array[j - gap];
                }
				
                // Вставка текущего элемента на своё место
                array[j] = temp;
            }
        }
    }
	
    public static void main(String[] args) {
        int[] array = {8, 5, 9, 3, 6, 7, 2, 4};
        System.out.println("Before sorting: " + Arrays.toString(array));
        shellSort(array);
        System.out.println("After sorting: " + Arrays.toString(array));
    }
}
```



### Варианты последовательностей шагов

1. **Оригинальная последовательность Дональда Шелла**
	- Формула: $gap = \lfloor n / 2^k \rfloor$, где $k = 1, 2, 3, \dots$
	- Пример: для $n = 16$ : $8, 4, 2, 1$
2. **Последовательность Хиббарда**
	- Формула: $gap = 2^k - 1$, где $k = 1, 2, 3, \dots$
	- Пример: $1, 3, 7, 15, \dots$
3. **Последовательность Седжвика**
	- Формула: $gap = 4^k + 3 \cdot 2^{k-1} + 1$, где $k = 0, 1, 2, \dots$
	- Пример: $1, 5, 19, 41, 109, \dots$
4. **Последовательность Прэтта**
	- Формула: $gap = 2^p \cdot 3^q$, где $p, q \geq 0$
	- Пример: $1, 2, 3, 4, 6, 8, 9, 12, \dots$
5. **Последовательность Кнута**
	- Формула: $gap = (3^k - 1) / 2$, где $k = 1, 2, 3, \dots$
	- Пример: $1, 4, 13, 40, 121, \dots$
6. **Последовательность Гонсалеса**
	- Формула: $gap = \lfloor n / 2.2^k \rfloor$, где $k = 0, 1, 2, \dots$
	- Пример: $1, 3, 7, 15, 31, \dots$
	- Временная сложность зависит от реализации, близка к $O(n^{5/4})$.

### Сводная таблица по вариантам шагов

| Последовательность | Лучший случай   | Средний случай  | Худший случай   |
| ------------------ | --------------- | --------------- | --------------- |
| **Шелла**          | $O(n \log^2 n)$ | $O(n^{3/2})$    | $O(n^2)$        |
| **Хиббарда**       | $O(n^{3/2})$    | $O(n^{5/4})$    | $O(n^{3/2})$    |
| **Седжвика**       | $O(n \log n)$   | $O(n^{4/3})$    | $O(n^{4/3})$    |
| **Прэтта**         | $O(n \log n)$   | $O(n \log n)$   | $O(n \log^2 n)$ |
| **Кнута**          | $O(n^{3/2})$    | $O(n^{5/4})$    | $O(n^{3/2})$    |
| **Гонсалеса**      | Зависит от шага | Зависит от шага | Зависит от шага |
### Легенда:
- $n$ — количество элементов массива.
- $k$ — номер текущего шага последовательности.
- Временная сложность ($O$):
  - **Лучший случай**: данные уже частично упорядочены.
  - **Средний случай**: случайные данные.
  - **Худший случай**: наихудшая конфигурация данных.


### Пространственная сложность:

Сортировка Шелла — это **in-place** алгоритм: $O(1)$
Не требует дополнительной памяти, кроме нескольких вспомогательных переменных.