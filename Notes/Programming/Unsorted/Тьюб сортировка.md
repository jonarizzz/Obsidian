Тьюб сортировка (tube sort) — это алгоритм сортировки, который представляет собой разновидность устойчивой сортировки с использованием вспомогательных структур данных, напоминающих “трубы” или “контейнеры” для распределения элементов. Алгоритм получил свое название из-за визуального сходства процесса распределения элементов по контейнерам, словно их помещают в трубы.


1. **Разбиение на контейнеры:** Элементы разбиваются на несколько контейнеров (труб) в зависимости от определенного критерия. Например, можно использовать диапазоны значений, как в сортировке подсчетом или карманной сортировке (bucket sort).
2. **Распределение:** Каждое значение помещается в соответствующий контейнер, основываясь на его значении. Это позволяет распределить элементы таким образом, что в каждом контейнере остаются элементы в ограниченном диапазоне значений.
3. **Сортировка в контейнерах:** После распределения элементы внутри каждого контейнера сортируются. Для сортировки внутри контейнера могут использоваться различные методы, например, быстрая сортировка или сортировка вставками.
4. **Слияние:** Наконец, элементы из всех контейнеров объединяются в один отсортированный список. Порядок элементов сохраняется в том виде, как они следовали в каждом контейнере, что делает сортировку устойчивой.


**Имплементация:**

```
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class TubeSort {

    public static void tubeSort(float[] arr) {
        int n = arr.length;
		
        // Шаг 1: Создаем контейнеры (трубы) для распределения элементов
        List<List<Float>> tubes = new ArrayList<>(n);
		
        for (int i = 0; i < n; i++) {
            tubes.add(new ArrayList<>());
        }
		
        // Шаг 2: Распределяем элементы по контейнерам
        for (float num : arr) {
			// Определяем, в какой контейнер попадет элемент
            int index = (int) (num * n); 
            tubes.get(index).add(num);
        }
		
        // Шаг 3: Сортируем каждый контейнер
        for (List<Float> tube : tubes) {
            Collections.sort(tube);
        }
		
        // Шаг 4: Собираем элементы из контейнеров в исходный массив
        int idx = 0;
        for (List<Float> tube : tubes) {
            for (float num : tube) {
                arr[idx++] = num;
            }
        }
    }

    public static void main(String[] args) {
        float[] arr = {0.78f, 0.17f, 0.39f, 0.26f, 0.72f, 0.94f, 
	        0.21f, 0.12f, 0.23f, 0.68f};
        System.out.println("Original array:");
        for (float num : arr) {
            System.out.print(num + " ");
        }

        tubeSort(arr);

        System.out.println("\nSorted array:");
        for (float num : arr) {
            System.out.print(num + " ");
        }
    }
}
```

**Сложность:**

**Временная сложность:**

- Распределение по контейнерам: $O(n)$, где $n$ — количество элементов в массиве.
- Сортировка каждого контейнера: В среднем каждый контейнер содержит $n/k$ элементов, где $k$ — количество контейнеров. Если использовать встроенный `Collections.sort()`, время сортировки в каждом контейнере будет примерно $O((n/k) log (n/k))$, а суммарная сложность для всех контейнеров составит $O(n log (n/k))$.
- Сборка из контейнеров: $O(n)$.
- В идеальном случае, когда количество контейнеров $k$ оптимально, средняя временная сложность алгоритма приближается к $O(n)$.

**Сложность по памяти:**

- Память для хранения контейнеров: Потребуется $O(n)$ дополнительных ячеек памяти для хранения элементов в контейнерах.
- Итого: $O(n)$ — основная дополнительная память для контейнеров.