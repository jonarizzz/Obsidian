Главная идея алгоритма — посчитать, сколько раз встречается каждый элемент в массиве, а потом заполнить исходный массив результатами этого подсчёта. Для этого нам нужен вспомогательный массив, где мы будем хранить результаты подсчёта. Даже если нам надо отсортировать миллион чисел, мы всё равно знаем диапазон этих чисел заранее, например, от 1 до 100. Это значит, что во вспомогательном массиве будет не миллион элементов, а сто.


1. Мы создаём вспомогательный массив и на старте заполняем его нулями.
2. Проходим по всему исходному массиву и смотрим очередное значение в ячейке.
3. Берём содержимое этой ячейки и увеличиваем на единицу значение вспомогательного массива под этим номером. Например, если мы встретили число 5, то увеличиваем на единицу пятый элемент вспомогательного массива. Если встретили 13 — тринадцатый.
4. После цикла во вспомогательном массиве у нас хранятся данные, сколько раз встречается каждый элемент.
5. Теперь мы проходим по вспомогательному массиву, и если в очередной ячейке лежит что-то больше нуля, то мы в исходный массив столько же раз отправляем номер этой ячейки. Например, в первой ячейке вспомогательного массива лежит число 7. Это значит, что в исходный массив мы отправляем единицу 7 раз подряд.


![[Сортировка подсчётом.gif]]


**Имплементация:**

```
import java.util.Arrays;

public class CountingSort {
    public static void countingSort(int[] array) {
        // Находим максимальное значение в массиве
        int max = Arrays.stream(array).max().orElse(0);
		
        // Создаем массив для подсчета, размер которого равен max + 1
        int[] countArray = new int[max + 1];
		
        // Заполняем массив подсчета
        for (int num : array) {
            countArray[num]++;
        }
		
        // Сортируем исходный массив на основе данных в countArray
        int index = 0;
        for (int i = 0; i < countArray.length; i++) {
            while (countArray[i] > 0) {
                array[index++] = i;
                countArray[i]--;
            }
        }
    }
	
    public static void main(String[] args) {
        int[] array = {4, 2, 2, 8, 3, 3, 1};
        System.out.println("Исходный массив: " + Arrays.toString(array));
        countingSort(array);
        System.out.println("Отсортированный массив: " + Arrays.toString(array));
    }
}
```


**Сложность:**

Временная сложность алгоритма составляет $O(n + k)$, потому что:
1. Заполнение массива подсчёта: Проход по всем элементам исходного массива для подсчёта количества вхождений занимает $O(n)$.
2. Заполнение исходного массива: Проход по массиву countArray (диапазон возможных значений) и вставка значений в исходный массив занимает $O(k)$.
3. Итак, суммарная временная сложность $O(n + k)$. Алгоритм эффективен, когда $k$ не слишком велико по сравнению с $n$.

Пространственная сложность также составляет $O(n + k)$, так как требуется:
1. Исходный массив: Хранение исходного массива из $n$ элементов.
2. Массив подсчёта: Массив countArray размером $k$, который хранит количество вхождений каждого возможного значения.
3. Таким образом, если диапазон $k$ велик по сравнению с $n$, сортировка подсчётом может оказаться неэффективной по памяти.