Другие названия — корзинная сортировка, блочная сортировка, карманная сортировка.  
  
Раскидываем числа по корзинам, затем в каждой корзине раскидываем по более мелким корзинам и так до тех пор пока на каком-то уровне в корзинке только одинаковые элементы. Тогда из таких корзин самого нижнего уровня легко восстановить массив в упорядоченном состоянии.

![[Сортировка корзинами.gif]]


**Имплементация:**

```
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class BucketSort {
    public static void bucketSort(float[] array) {
        int n = array.length;
        if (n <= 0) return;
		
        // Шаг 1: Создаем пустые ведра
        List<Float>[] buckets = new ArrayList[n];
        for (int i = 0; i < n; i++) {
            buckets[i] = new ArrayList<>();
        }
		
        // Шаг 2: Распределяем элементы по ведрам
        for (float num : array) {
            int bucketIndex = (int) (num * n);
            buckets[bucketIndex].add(num);
        }
		
        // Шаг 3: Сортируем каждое ведро
        for (List<Float> bucket : buckets) {
            Collections.sort(bucket);
        }
		
        // Шаг 4: Собираем элементы из ведер обратно в массив
        int index = 0;
        for (List<Float> bucket : buckets) {
            for (float num : bucket) {
                array[index++] = num;
            }
        }
    }
	
    public static void main(String[] args) {
        float[] array = {0.42f, 0.32f, 0.52f, 0.25f, 0.47f, 0.51f};
        System.out.println("До сортировки:");
        for (float num : array) {
            System.out.print(num + " ");
        }
		
        bucketSort(array);
		
        System.out.println("\nПосле сортировки:");
        for (float num : array) {
            System.out.print(num + " ");
        }
    }
}
```



**Сложность:**

По времени
- **Средний случай**: $O(n + k)$, где $n$ — количество элементов, а $k$ — количество ведер. При равномерном распределении элементов по ведрам и использовании эффективного алгоритма сортировки внутри каждого ведра ведерная сортировка работает довольно быстро.
- **Лучший случай**: $O(n)$, когда элементы равномерно распределены по ведрам, и каждый из них содержит мало элементов, что минимизирует время на сортировку внутри ведер.
- **Худший случай**: $O(n^2)$, если все элементы попадают в одно ведро (например, если распределение данных неравномерно), что превращает ведерную сортировку в обычную сортировку внутри одного ведра, чаще всего с квадратичной сложностью.

По памяти
- Памятная сложность ведерной сортировки составляет $O(n + k)$, где $n$ — количество элементов, а $k$ — количество ведер. Память расходуется на хранение ведер и элементов в них, но дополнительная память на сортировку внутри каждого ведра также может потребоваться в зависимости от выбранного алгоритма сортировки для каждого ведра.