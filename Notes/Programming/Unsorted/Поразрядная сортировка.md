
Поразрядная сортировка (или **radix sort**) — это алгоритм сортировки, который сортирует элементы по разрядам их числовых значений. Этот алгоритм особенно эффективен для сортировки целых чисел или строк с одинаковой длиной. Он работает не напрямую с самими числами, а с их разрядами (цифрами или символами), что позволяет обрабатывать элементы поочередно.

1. Определение разряда: Для каждого числа (или строки) определяется разряд, с которого будет начинаться сортировка (например, для чисел — с младшего разряда, для строк — с первого символа).
2. Сортировка по разряду: Все числа (или строки) сортируются по текущему разряду. Это можно сделать с помощью стабильной сортировки, например, с использованием сортировки подсчётом ([[Сортировка подсчётом]]).
3. Переход к следующему разряду: После того как все элементы отсортированы по текущему разряду, переходят к следующему разряду и повторяют процесс.
4. Завершение: Алгоритм повторяет этот процесс до тех пор, пока не будут обработаны все разряды.


**Имплементация:**

```
import java.util.Arrays;

public class RadixSort {

    // Метод для выполнения сортировки по разрядам
    public static void radixSort(int[] arr) {
        // Находим максимальное число в массиве
        int max = Arrays.stream(arr).max().getAsInt();
        // Проходим по всем разрядам, начиная с младшего
        for (int exp = 1; max / exp > 0; exp *= 10) {
            countingSortByDigit(arr, exp);
        }
    }
	
    // Сортировка по разряду, используя сортировку подсчётом
    private static void countingSortByDigit(int[] arr, int exp) {
        int n = arr.length;
        int[] output = new int[n]; // Массив для хранения отсортированных значений
        int[] count = new int[10]; // Счётчики для цифр от 0 до 9
		
        // Подсчитываем количество встречающихся цифр
        for (int i = 0; i < n; i++) {
            count[(arr[i] / exp) % 10]++;
        }
		
        // Изменяем count[i], так чтобы count[i] содержал 
        // фактическую позицию цифры в output[]
        for (int i = 1; i < 10; i++) {
            count[i] += count[i - 1];
        }
		
        // Строим отсортированный массив, обрабатывая элементы с конца, чтобы сохранить стабильность сортировки
        for (int i = n - 1; i >= 0; i--) {
            int digit = (arr[i] / exp) % 10;
            output[count[digit] - 1] = arr[i];
            count[digit]--;
        }
        // Копируем отсортированные элементы обратно в исходный массив
        System.arraycopy(output, 0, arr, 0, n);
    }

    // Пример использования
    public static void main(String[] args) {
        int[] arr = {170, 45, 75, 90, 802, 24, 2, 66};
        System.out.println("Исходный массив: " + Arrays.toString(arr));
        radixSort(arr);
        System.out.println("Отсортированный массив: " + Arrays.toString(arr));
    }
}
```


**Сложность по времени:**  

- В общем случае: $O(d \cdot (n + k))$
- Если  $d$  и  $k$  константы, сложность становится линейной:  $O(n)$

**Затраты по памяти:**

- Требуется  $O(n + k)$  памяти для временных массивов, используемых в сортировке по разрядам.
- Общая память:  $O(n + k)$ , где  $k$  зависит от используемой системы счисления.

**Ограничения:**

Алгоритм работает только для числовых данных или строк фиксированной длины.
Для больших  $d$  и  $k$  может уступать алгоритмам сравнения $O(n \log n)$ из-за роста времени и памяти.

**Легенда:**

- $n$  — количество элементов.
- $d$  — число разрядов.
- $k$  — размер алфавита (например,  10  для десятичной системы).