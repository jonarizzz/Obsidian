**SELECT ... FOR UPDATE** – это специальный [[{TODO} SQL (Structured Query Language)||SQL]]-запрос, который блокирует выбранные строки в [[Транзакция (Transaction)||транзакции]] до ее завершения ([[{TODO} Подтверждение Транзакции (Фиксирование Транзакции, Commit Transaction)||COMMIT]] или [[Откат Транзакции (Rollback)||ROLLBACK]]).

- Используется для [[Пессимистичная Блокировка (Pessimistic Locking)||пессимистичной блокировки]] – предотвращает изменение этих строк другими [[Транзакция (Transaction)||транзакциями]].
- Применяется в системах, где важна [[Высокая Согласованность (Strong Consistency)||строгая согласованность]] данных (например, при обновлении баланса счета).


### Как работает

**Пример без блокировки (возможна [[Гонки Данных (Data Races)||гонка данных]])**

Допустим, два запроса читают баланс и оба пытаются его обновить:

```sql
-- Клиент A читает баланс
SELECT balance FROM accounts WHERE id = 1;  -- balance = 100

-- Клиент B тоже читает баланс
SELECT balance FROM accounts WHERE id = 1;  -- balance = 100

-- Клиент A списывает 50
UPDATE accounts SET balance = 50 WHERE id = 1;

-- Клиент B тоже списывает 50, но исходные данные устарели!
UPDATE accounts SET balance = 50 WHERE id = 1;
```

**Итог:** баланс стал 50, хотя списания было два → потеря данных!


**Пример с FOR UPDATE (исключаем [[Гонки Данных (Data Races)||гонки данных]])**

```sql
-- Клиент A начинает транзакцию и блокирует строку
BEGIN;
SELECT balance FROM accounts WHERE id = 1 FOR UPDATE;  -- balance = 100

-- Клиент B тоже пытается обновить баланс, но ждет, пока Клиент A завершит транзакцию
BEGIN;
SELECT balance FROM accounts WHERE id = 1 FOR UPDATE;  -- Ожидание блокировки

-- Клиент A списывает 50
UPDATE accounts SET balance = balance - 50 WHERE id = 1;

-- Клиент A фиксирует изменения
COMMIT;

-- Теперь Клиент B получает баланс 50 и может провести свою операцию
SELECT balance FROM accounts WHERE id = 1 FOR UPDATE;  -- balance = 50
```

**Итог:** никакие обновления не теряются, конкурентные запросы выполняются последовательно.


### Когда использовать
  
- При работе с балансами, складскими остатками, бронированием мест.
- Когда важно избежать гонок данных ([[Гонки Данных (Data Races)||race conditions]]).
- Когда нужен строгий контроль последовательности операций.


### Когда не использовать

- **При высокой нагрузке** – может вызывать [[Блокировки (Locking)||блокировки]] и снижать производительность.
- **Когда нужна [[Масштабирование (Скейлинг, Scaling)||масштабируемость]]** – лучше использовать [[Оптимистичная Блокировка (Optimistic Locking)||оптимистичную блокировку]] (version или updated_at).
- **В распределенных системах** – в этом случае лучше использовать [[{TODO} Redlock||Redis-блокировки]] или [[Сага (SAGA)||SAGA-паттерны]].